mode: bf

# Exchanges to include (leaner prod set; can expand as needed)
ex: [binance, bitget, mexc, okx]

quote: USDT
inv: 0.0  # Always use wallet; do not assume extra investment

bf:
  # Anchors restringidas a stables líquidas para evitar exposure a fiat con gaps grandes.
  # allowed_quotes: [USDT, USDC]
  allowed_quotes: [USDT,USDC, TUSD, USDP, EURS, PAXG]

  fee: 0.10                  # Mantiene modelado conservador de taker≈0.1% por hop
  rank_by_qvol: true         # Prioriza liquidez (reduce ciclos basura)
  currencies_limit: 600      # Menor universo = menor ruido, más rápido (era 600)
  min_net: -0.02               # Sube el umbral bruto para absorber slippage potencial (~0.4% observado)
  min_net_per_hop: 0.00      # Evita cadenas largas con hops marginales
  top: 40                    # Suficiente para inspección; menos ruido que 60
  require_quote: true        # Obliga cerrar en ancla estable
  require_topofbook: false    # Usa solo bid/ask; no fallback a 'last'
  min_quote_vol: 1000        # Filtra hops de bajo volumen (mitiga libros delgados ALICE/TRY style)
  min_hops: 1                # Minimiza ciclos demasiado cortos (ajusta según preferencia)
  max_hops: 5               # Reduce complejidad y acumulación de fees/slippage (antes 7)
  threads: 0                 # Paralelismo por exchange
  require_dual_quote: false  # Mantener flexible entre USDT/USDC
  persist_top_csv: true
  revalidate_depth: true     # Re-chequea profundidad antes de aceptar ciclo
  use_ws: true               # WS para menor latencia (binance soportado)
  depth_levels: 10           # Niveles para fallback REST en depth revalidation
  latency_penalty_bps: 0    # Descuenta 0.25% del net revalidado para cubrir micro-lag
  reset_history: true
  iter_timeout_sec: 0.0

max: 280                    # Alinear con reducción de currencies_limit para calidad
timeout: 20000
sleep: 0
repeat: 10000
repeat_sleep: 0

# Note: use_balance/balance_kind removed; tool now always reads wallet balances when available
balance_provider: ccxt
ex_auth_only: true
simulate_compound: true
simulate_from_wallet: true
simulate_prefer: auto
simulate_select: best
simulate_auto_switch: true
simulate_fallback_to_inv: false

no_console_clear: true

ui:
  progress_bar: true
  progress_len: 20
  spinner_frames: "|/-\\"
  draw_tables_first: true
  show_simulation_header_always: true

tri:
  fee: 0.10
  currencies_limit: 600
  min_net: -0.02
  top: 40
  require_topofbook: false
  min_quote_vol: 1000

# Manual blacklist (prod) – evita rutas con pares restringidos
# OKX: USDC/USDT con errores sCode 51155 (compliance) en swaps recientes
blacklist_pairs:
  okx:
    - USDC/USDT  # sCode 51155 compliance restriction


# NOTAS de endurecimiento:
# - require_topofbook + min_quote_vol + revalidate_depth + latency_penalty reducen falsos positivos.
# - min_net elevado (0.6%) + min_net_per_hop evita que micro spreads sumen aparente net positivo frágil.
# - Blacklist temporal de TRY hops específicos tras pérdida real; revisar y retirar si se estabilizan.

def tri_worker(ex_id: str, it: int, ts: str) -> Tuple[str, List[str], List[dict]]:
    # Copia la lógica actual del ciclo tri para un solo exchange
    local_lines: List[str] = []
    local_results: List[dict] = []
    try:
        ex = load_exchange(ex_id, args.timeout)
        if not safe_has(ex, "fetchTickers"):
            return ex_id, local_lines, local_results
        markets = ex.load_markets()
        tickers = ex.fetch_tickers()
        # ... resto de la lógica tri para ese exchange ...
        # Puedes copiar el cuerpo del ciclo actual de tri aquí
    except Exception as e:
        logger.warning(f"{ex_id}: tri_worker error: {e}")
    return ex_id, local_lines, local_results
